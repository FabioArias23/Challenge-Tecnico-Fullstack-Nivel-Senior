This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2026-01-20 05:57:14

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
.gitignore
docker-compose.yml
Dockerfile
env.example
nest-cli.json
package.json
src
  app.module.ts
  app.service.ts
  auth
    decorators
      current-user.decorator.ts
      public.decorator.ts
      roles.decorator.ts
    dto
      login.dto.ts
    guards
      jwt-auth.guard.ts
      roles.guard.ts
    index.ts
    services
      cognito-mock.service.ts
  entities
    billing-batch.entity.ts
    billing-pending.entity.ts
    index.ts
    invoice.entity.ts
    service.entity.ts
tsconfig.build.json
tsconfig.json
```

# Repository Files


## .gitignore

```text
# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
package-lock.json
yarn.lock

# Environment variables
.env
.env.local
.env.*.local

# Build outputs
dist/
build/
*.tsbuildinfo

# IDE
.vscode/
.idea/
*.swp
*.swo
*~
.DS_Store

# Testing
coverage/
.nyc_output/
*.log

# Docker
.dockerignore

# OS
Thumbs.db
```

## docker-compose.yml

```yaml
services:
  postgres:
    image: postgres:14.4-alpine
    container_name: billing_challenge_db
    ports:
      - "5434:5432"
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=billing_challenge
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - billing_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  api:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: billing_challenge_api
    ports:
      - "3057:3000"
    env_file:
      - .env
    volumes:
      - ./src:/app/src
      - node_modules:/app/node_modules
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - billing_network
    command: npm run start:dev

volumes:
  postgres_data:
    driver: local
  node_modules:
    driver: local

networks:
  billing_network:
    driver: bridge
```

## Dockerfile

```text
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./

RUN npm install

COPY . .

EXPOSE 3000

CMD ["npm", "run", "start:dev"]
```

## env.example

```text
# Database
DB_HOST=postgres
DB_PORT=5432
DB_USERNAME=postgres
DB_PASSWORD=postgres
DB_DATABASE=billing_challenge

# Application
PORT=3000
NODE_ENV=development

# JWT (para autenticación con Cognito o mock)
JWT_SECRET=your-secret-key-change-in-production
JWT_EXPIRES_IN=24h
```

## nest-cli.json

```json
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}
```

## package.json

```json
{
  "name": "billing-challenge-starter",
  "version": "1.0.0",
  "description": "Challenge técnico - Sistema de Facturación por Lote",
  "author": "",
  "private": true,
  "license": "MIT",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "typeorm": "typeorm-ts-node-commonjs",
    "typeorm:migrate": "npm run typeorm migration:generate -- -d src/config/ormconfig.ts",
    "typeorm:run": "ts-node --require tsconfig-paths/register node_modules/typeorm/cli.js migration:run -d src/config/ormconfig.ts",
    "typeorm:revert": "npm run typeorm migration:revert -- -d src/config/ormconfig.ts"
  },
  "dependencies": {
    "@nestjs/common": "^8.4.7",
    "@nestjs/config": "^2.1.0",
    "@nestjs/core": "^8.4.7",
    "@nestjs/jwt": "^8.0.1",
    "@nestjs/passport": "^8.2.2",
    "@nestjs/platform-express": "^8.4.7",
    "passport": "^0.6.0",
    "passport-jwt": "^4.0.1",
    "@nestjs/swagger": "^5.2.1",
    "swagger-ui-express": "^5.0.0",
    "@nestjs/typeorm": "^8.0.3",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.1",
    "dotenv": "^16.0.1",
    "pg": "^8.7.3",
    "reflect-metadata": "^0.1.13",
    "rxjs": "^7.8.1",
    "typeorm": "^0.3.20"
  },
  "devDependencies": {
    "@nestjs/cli": "^8.2.8",
    "@nestjs/schematics": "^9.2.0",
    "@nestjs/testing": "^8.4.7",
    "@types/express": "^4.17.13",
    "@types/jest": "^28.1.2",
    "@types/node": "^18.0.0",
    "@types/supertest": "^2.0.12",
    "@typescript-eslint/eslint-plugin": "^8.0.0",
    "@typescript-eslint/parser": "^8.0.0",
    "eslint": "^8.42.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^5.0.0",
    "jest": "^29.5.0",
    "prettier": "^3.0.0",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.1.0",
    "ts-loader": "^9.4.3",
    "ts-node": "^10.9.1",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.1.3"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}
```

## src/app.module.ts

```typescript
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';
import { APP_GUARD } from '@nestjs/core';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { DatabaseConfig } from './config/database.config';
import { AuthModule } from './auth/auth.module';
import { JwtAuthGuard } from './auth/guards/jwt-auth.guard';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: '.env',
    }),
    TypeOrmModule.forRootAsync({
      imports: [ConfigModule],
      useClass: DatabaseConfig,
      inject: [ConfigService],
    }),
    AuthModule,
  ],
  controllers: [AppController],
  providers: [
    AppService,
    {
      provide: APP_GUARD,
      useClass: JwtAuthGuard,
    },
  ],
})
export class AppModule {}
```

## src/app.service.ts

```typescript
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Billing Challenge API - Sistema de Facturación por Lote';
  }
}
```

## src/auth/decorators/current-user.decorator.ts

```typescript
import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const CurrentUser = createParamDecorator(
  (data: unknown, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    return request.user;
  },
);
```

## src/auth/decorators/public.decorator.ts

```typescript
import { SetMetadata } from '@nestjs/common';

export const IS_PUBLIC_KEY = 'isPublic';
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);
```

## src/auth/decorators/roles.decorator.ts

```typescript
import { SetMetadata } from '@nestjs/common';

export const ROLES_KEY = 'roles';
export const Roles = (...roles: string[]) => SetMetadata(ROLES_KEY, roles);
```

## src/auth/dto/login.dto.ts

```typescript
import { ApiProperty } from '@nestjs/swagger';
import { IsString, IsNotEmpty } from 'class-validator';

export class LoginDto {
  @ApiProperty({ example: 'test', description: 'Username for login' })
  @IsString()
  @IsNotEmpty()
  username: string;

  @ApiProperty({ example: 'test', description: 'Password for login' })
  @IsString()
  @IsNotEmpty()
  password: string;
}
```

## src/auth/guards/jwt-auth.guard.ts

```typescript
import {
  ExecutionContext,
  Injectable,
  UnauthorizedException,
} from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { Reflector } from '@nestjs/core';
import { IS_PUBLIC_KEY } from '../decorators/public.decorator';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  constructor(private reflector: Reflector) {
    super();
  }

  canActivate(context: ExecutionContext) {
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);

    if (isPublic) {
      return true;
    }

    return super.canActivate(context);
  }

  handleRequest(err: any, user: any, info: any) {
    if (err || !user) {
      throw err || new UnauthorizedException('Invalid or missing token');
    }
    return user;
  }
}
```

## src/auth/guards/roles.guard.ts

```typescript
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { ROLES_KEY } from '../decorators/roles.decorator';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<string[]>(ROLES_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);

    if (!requiredRoles) {
      return true;
    }

    const request = context.switchToHttp().getRequest();
    const user = request.user;

    if (!user) {
      return false;
    }

    return requiredRoles.some((role) => user.roles?.includes(role));
  }
}
```

## src/auth/index.ts

```typescript
export { JwtAuthGuard } from './guards/jwt-auth.guard';
export { RolesGuard } from './guards/roles.guard';
export { Public } from './decorators/public.decorator';
export { Roles } from './decorators/roles.decorator';
export { CurrentUser } from './decorators/current-user.decorator';
export { CognitoMockService } from './services/cognito-mock.service';
export { AuthModule } from './auth.module';
```

## src/auth/services/cognito-mock.service.ts

```typescript
import { Injectable, BadRequestException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class CognitoMockService {
  constructor(
    private jwtService: JwtService,
    private configService: ConfigService,
  ) {}

  async login(username: string, password: string): Promise<{ accessToken: string }> {
    if (!username || !password) {
      throw new BadRequestException('Username and password are required');
    }

    const payload = {
      sub: username,
      username: username,
      email: `${username}@example.com`,
      'cognito:groups': ['USER'],
    };

    const accessToken = this.jwtService.sign(payload);

    return { accessToken };
  }

  async validateToken(token: string): Promise<any> {
    try {
      return this.jwtService.verify(token);
    } catch (error) {
      throw new Error('Invalid token');
    }
  }
}
```

## src/entities/billing-batch.entity.ts

```typescript
import {
  Entity,
  Column,
  PrimaryGeneratedColumn,
  CreateDateColumn,
  UpdateDateColumn,
  OneToMany,
} from 'typeorm';
import { Invoice } from './invoice.entity';

export enum BatchStatus {
  PROCESSED = 'PROCESSED',
  ERROR = 'ERROR',
}

@Entity('billing_batches')
export class BillingBatch {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ type: 'date' })
  issueDate: Date;

  @Column()
  receiptBook: string;

  @Column({
    type: 'enum',
    enum: BatchStatus,
    default: BatchStatus.PROCESSED,
  })
  status: BatchStatus;

  @Column({ type: 'text', nullable: true })
  errorMessage: string;

  @OneToMany(() => Invoice, (invoice) => invoice.batch)
  invoices: Invoice[];

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}
```

## src/entities/billing-pending.entity.ts

```typescript
import {
  Entity,
  Column,
  PrimaryGeneratedColumn,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  JoinColumn,
  OneToMany,
} from 'typeorm';
import { Service } from './service.entity';
import { Invoice } from './invoice.entity';

export enum PendingStatus {
  PENDING = 'PENDING',
  INVOICED = 'INVOICED',
}

@Entity('billing_pendings')
export class BillingPending {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  serviceId: number;

  @ManyToOne(() => Service, (service) => service.pendings)
  @JoinColumn({ name: 'serviceId' })
  service: Service;

  @Column({
    type: 'enum',
    enum: PendingStatus,
    default: PendingStatus.PENDING,
  })
  status: PendingStatus;

  @OneToMany(() => Invoice, (invoice) => invoice.pending)
  invoices: Invoice[];

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}
```

## src/entities/index.ts

```typescript
export { Service, ServiceStatus } from './service.entity';
export { BillingPending, PendingStatus } from './billing-pending.entity';
export { BillingBatch, BatchStatus } from './billing-batch.entity';
export { Invoice } from './invoice.entity';
```

## src/entities/invoice.entity.ts

```typescript
import {
  Entity,
  Column,
  PrimaryGeneratedColumn,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  JoinColumn,
} from 'typeorm';
import { BillingBatch } from './billing-batch.entity';
import { BillingPending } from './billing-pending.entity';

@Entity('invoices')
export class Invoice {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  invoiceNumber: string;

  @Column()
  cae: string;

  @Column({ type: 'date' })
  issueDate: Date;

  @Column({ type: 'decimal', precision: 10, scale: 2 })
  amount: number;

  @Column()
  batchId: number;

  @ManyToOne(() => BillingBatch, (batch) => batch.invoices)
  @JoinColumn({ name: 'batchId' })
  batch: BillingBatch;

  @Column()
  pendingId: number;

  @ManyToOne(() => BillingPending, (pending) => pending.invoices)
  @JoinColumn({ name: 'pendingId' })
  pending: BillingPending;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}
```

## src/entities/service.entity.ts

```typescript
import {
  Entity,
  Column,
  PrimaryGeneratedColumn,
  CreateDateColumn,
  UpdateDateColumn,
  OneToMany,
} from 'typeorm';
import { BillingPending } from './billing-pending.entity';

export enum ServiceStatus {
  CREATED = 'CREATED',
  SENT_TO_BILL = 'SENT_TO_BILL',
  INVOICED = 'INVOICED',
}

@Entity('services')
export class Service {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ type: 'date' })
  serviceDate: Date;

  @Column()
  customerId: number;

  @Column({ type: 'decimal', precision: 10, scale: 2 })
  amount: number;

  @Column({
    type: 'enum',
    enum: ServiceStatus,
    default: ServiceStatus.CREATED,
  })
  status: ServiceStatus;

  @OneToMany(() => BillingPending, (pending) => pending.service)
  pendings: BillingPending[];

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}
```

## tsconfig.build.json

```json
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}
```

## tsconfig.json

```json
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": false,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "forceConsistentCasingInFileNames": false,
    "noFallthroughCasesInSwitch": false,
    "paths": {
      "@/*": ["src/*"]
    }
  }
}
```

## Statistics

- Total Files: 23
- Total Characters: 29391
- Total Tokens: 0
